<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on Phase</title>
    <link>https://phase.blog/reference/</link>
    <description>Recent content in Introduction on Phase</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 02 Feb 2022 23:16:22 -0700</lastBuildDate><atom:link href="https://phase.blog/reference/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Crystal&#39;s Slicing Mechanisms</title>
      <link>https://phase.blog/reference/docs/regions_and_chunks/crystal_slicing_mechanisms/</link>
      <pubDate>Wed, 02 Feb 2022 23:16:22 -0700</pubDate>
      
      <guid>https://phase.blog/reference/docs/regions_and_chunks/crystal_slicing_mechanisms/</guid>
      <description>Crystal&amp;rsquo;s Slicing Mechanisms #  In an Array (or any Indexable), each element is represented by a numeric index. There are a couple different ways to do this
 we can refer to the elements via positive, increasing indexes as such:  arr = [&amp;#39;P&amp;#39;, &amp;#39;h&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;e&amp;#39;] # 0 1 2 3 4 arr[0] # =&amp;gt; &amp;#39;P&amp;#39; arr[4] # =&amp;gt; &amp;#39;e&amp;#39; Or, we can start at the other end of the array using negative indexes:</description>
    </item>
    
    <item>
      <title>multiindexable_tutorial</title>
      <link>https://phase.blog/reference/docs/tutorials/making-a-multiindexable/</link>
      <pubDate>Tue, 17 Aug 2021 15:38:22 -0700</pubDate>
      
      <guid>https://phase.blog/reference/docs/tutorials/making-a-multiindexable/</guid>
      <description>Tutorial: Make Your Own MultiIndexable #  Basics #  ph-core offers a standard data type, Phase::NArray that will suffice for most of your multidimensional data storage and manipulation needs. However, storing information linearly in memory isn&amp;rsquo;t always the most effective appraoch, and sometimes isn&amp;rsquo;t possible. Phase::MultiIndexable is an interface defining a common set of rules we expect any multidimensional array to obey; and by implementing this interface, you can treat your own type almost like an NArray.</description>
    </item>
    
    <item>
      <title>MultiIndexable Slicing</title>
      <link>https://phase.blog/reference/docs/regions_and_chunks/multiindexable_slicing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://phase.blog/reference/docs/regions_and_chunks/multiindexable_slicing/</guid>
      <description>MultiIndexable Slicing #  In Phase, slicing multidimensional arrays (MultiIndexabless) is designed to be very similar to slicing ordinary arrays. In fact, for single-dimensional MultiIndexables, slicing is almost identical:
require &amp;#34;phase&amp;#34; include Phase # Vanilla crystal slicing: arr = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;] arr[1..] # =&amp;gt; [&amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;] # 1D MultiIndexable slicing: narr = NArray[&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;] narr[1..] # =&amp;gt; NArray[&amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;] Basic Example #  When we add another dimension, we must specify two sets of indexes.</description>
    </item>
    
    <item>
      <title>The IndexRegion Type</title>
      <link>https://phase.blog/reference/docs/regions_and_chunks/index_region/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://phase.blog/reference/docs/regions_and_chunks/index_region/</guid>
      <description>The IndexRegion Type #  </description>
    </item>
    
  </channel>
</rss>
